b"Problem\nNaveen made an encryption algorithm for the Introduction to Cryptography course project. The algorithm takes input a bit-string SSS of length NNN and returns a ciphertext of the same length. The pseudo-code for the algorithm is -\nEncryption (S, N )\r\n{\r\n    cipher = S\r\n    for i \xe2\x86\x92 1 to N : \r\n        j = ( i == N ) ? 1 : i+1\r\n        if ( S[i] == '1' and S[j] == '0' ) :\r\n            cipher[i] = '0'\r\n            cipher[j] = '1'\r\n\r\n    return cipher        \r\n}\n\nNote:\n\nSSS contains only '1's and '0's.\nThe given algorithm works on 1-based indexing.\n\nFor example, if the original bit-string SSS was 010101, the encryption function returns 101010.\nUnfortunately, the above algorithm is not perfect, as more than one SSS can have the same ciphertext.\nFor a given ciphertext, Naveen wants to find out how many original bit-string SSS are possible.\nFor example, for the ciphertext '01001', there are two possible original strings - '10001' and '10010'.\nNaveen is busy preparing for the end-sem exams, can you help him by implementing a function that calculates the total possible original strings for a given ciphertext?.\nThe answer can be very large, so print answeransweranswer% (109+7)(10 ^9 + 7)(109+7).\n\nInput:\n\nFirst-line will contain TTT, the number of test cases.\nEach test case contains a single line of input, a string consists of 1s and 0s.\n\nOutput:\n\nFor each test case print an integer, answeransweranswer% (109+7)(10 ^ 9 +7)(109+7) for the problem in a separate line.\n\nConstraints\n\n1\xe2\x89\xa4T\xe2\x89\xa4101 \\leq T \\leq 101\xe2\x89\xa4T\xe2\x89\xa410\n2\xe2\x89\xa4lengthOfString\xe2\x89\xa41052 \\leq length Of String \\leq 10 ^ 52\xe2\x89\xa4lengthOfString\xe2\x89\xa4105\nSum of length of strings over all test cases does not exceed 10510 ^ 5105.\n\nSample Input:\n2\r\n010001001\r\n101010\n\nSample Output:\n2\r\n4\n\nEXPLANATION:\nIn the first sample, the only possible original strings are 100010010100010010100010010 and 100010001100010001100010001."