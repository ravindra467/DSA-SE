b'Problem\n\xc2\xa0Loki was working with binary strings and he encountered an interesting problem.\n\xc2\xa0In Loki\'s world, binary strings are stored in reverse, i.e., the least significant bit is stored in the first character of the string, the next significant bit is stored in the second character, and so on; the most significant bit is stored in the last character.\n Let N be the number of bits in the binary string \nLoki was going to add "1" to this binary string. Find the number of bits among the N bits of the string which change their state. \n  If the result of the addition to the binary string increases the number of bits, the newly formed bits are discarded.  \nInput\n The first line consists of T, the number of test cases. Each case consists of S, the binary string, on a single line. \nOutput\nPrint one integer for each test case - the number of bits in the string whose state changes, when we add the value "1" to the string. \nConstraints\n 1 <= T <= 10\n 1 <= Length of String S, i.e., |S| <= 100 \nExample\nInput:\n3\n0\n100\n11\nOutput:\n1\n2\n2\n\n\xc2\xa0\nExplanation\nExample case 1. The binary string is "0". When we add "1" to it, it becomes "1". Hence, the number of bits which changed their state is 1. \nExample case 2. The binary string is "001". When we add "1" to it, it becomes "010". Hence, the number of bits which changed their state is 2. \nExample case 3. The binary string is "11". When we add "1" to it, it becomes "100". But we will discard newly added bits from the string, as mentioned in the problem. Hence the answer is 2. '